{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask-Worker Flask-Worker simplifies interaction with a Redis Queue for executing long-running tasks in a Flask application. Long-running tasks are managed by a Worker, who sends the client a loading page until it completes the task. Upon completing the task, the Worker automatically replaces the client's window with the loaded page. Why Flask-Worker Suppose we have a view function which needs to execute a complex task before the client can view the page. What we want is for the complex task to run once, and for the view function to return a loading page while the complex task is running. Our first pass might be: @app.route('/') def index(): return complex_task() Unfortunately, the view function executes the complex task every time it is called. To make matters worse, the client has no indication that the complex task is in progress. Each time the client tries to refresh the page, the complex task is queued up again. Flask-Worker solves this problem. We set up a Worker: class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name self.set(complex_task) super().__init__() And call it in a view function: @app.route('/') def index(): worker = get_model(Worker, name='index') return worker.result if worker.job_finished else worker() See the tutorial for a complete example. Installation $ pip install flask-worker Citation @software{bowen2020flask-worker, author = {Dillon Bowen}, title = {Flask-Worker}, url = {https://dsbowen.github.io/flask-worker/}, date = {2020-06-15}, } License Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"Home"},{"location":"#flask-worker","text":"Flask-Worker simplifies interaction with a Redis Queue for executing long-running tasks in a Flask application. Long-running tasks are managed by a Worker, who sends the client a loading page until it completes the task. Upon completing the task, the Worker automatically replaces the client's window with the loaded page.","title":"Flask-Worker"},{"location":"#why-flask-worker","text":"Suppose we have a view function which needs to execute a complex task before the client can view the page. What we want is for the complex task to run once, and for the view function to return a loading page while the complex task is running. Our first pass might be: @app.route('/') def index(): return complex_task() Unfortunately, the view function executes the complex task every time it is called. To make matters worse, the client has no indication that the complex task is in progress. Each time the client tries to refresh the page, the complex task is queued up again. Flask-Worker solves this problem. We set up a Worker: class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name self.set(complex_task) super().__init__() And call it in a view function: @app.route('/') def index(): worker = get_model(Worker, name='index') return worker.result if worker.job_finished else worker() See the tutorial for a complete example.","title":"Why Flask-Worker"},{"location":"#installation","text":"$ pip install flask-worker","title":"Installation"},{"location":"#citation","text":"@software{bowen2020flask-worker, author = {Dillon Bowen}, title = {Flask-Worker}, url = {https://dsbowen.github.io/flask-worker/}, date = {2020-06-15}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the MIT License .","title":"License"},{"location":"factory/","text":"Application factory Flask-Worker requires a Flask application with three extensions: A Flask-SQLAlchemy database A Flask-SocketIO socket A Flask-Worker manager The cleanest design uses an application factory . We'll store this in a file called factory.py . from flask_worker import Manager from flask import Flask from flask_socketio import SocketIO from flask_sqlalchemy import SQLAlchemy from redis import Redis from rq import Queue import eventlet import os db = SQLAlchemy() eventlet.monkey_patch(socket=True) socketio = SocketIO(asynch_mode='eventlet') # initialize a Manager with the database and socketio manager = Manager(db=db, socketio=socketio) def create_app(): app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = ( 'sqlite:///'+os.path.join(os.getcwd(), 'data.db') ) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.redis = Redis.from_url('redis://') app.task_queue = Queue('my-task-queue', connection=app.redis) db.init_app(app) socketio.init_app(app, message_queue='redis://') # initialize the manager with the application manager.init_app(app) return app","title":"Factory"},{"location":"factory/#application-factory","text":"Flask-Worker requires a Flask application with three extensions: A Flask-SQLAlchemy database A Flask-SocketIO socket A Flask-Worker manager The cleanest design uses an application factory . We'll store this in a file called factory.py . from flask_worker import Manager from flask import Flask from flask_socketio import SocketIO from flask_sqlalchemy import SQLAlchemy from redis import Redis from rq import Queue import eventlet import os db = SQLAlchemy() eventlet.monkey_patch(socket=True) socketio = SocketIO(asynch_mode='eventlet') # initialize a Manager with the database and socketio manager = Manager(db=db, socketio=socketio) def create_app(): app = Flask(__name__) app.config['SQLALCHEMY_DATABASE_URI'] = ( 'sqlite:///'+os.path.join(os.getcwd(), 'data.db') ) app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False app.redis = Redis.from_url('redis://') app.task_queue = Queue('my-task-queue', connection=app.redis) db.init_app(app) socketio.init_app(app, message_queue='redis://') # initialize the manager with the application manager.init_app(app) return app","title":"Application factory"},{"location":"img/","text":"Loading image The worker's loading page displays an image while waiting for its complex task to finish. Flask-Worker looks for a loading image named worker_loading.gif in the app's static directory. Our folder looks like: static/ worker_loading.gif factory.py models.py See the API for details on customizing the loading page.","title":"Loading image"},{"location":"img/#loading-image","text":"The worker's loading page displays an image while waiting for its complex task to finish. Flask-Worker looks for a loading image named worker_loading.gif in the app's static directory. Our folder looks like: static/ worker_loading.gif factory.py models.py See the API for details on customizing the loading page.","title":"Loading image"},{"location":"manager/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Manager flask_worker. Manager class flask_worker. Manager ( app=None, **kwargs ) [source] Flask extension which manages workers. The manager tracks an application import path, a redis connection, the application database, and the web socket. These tools will be invoked by workers. Parameters: app : flask.app.Flask or None, default=None Flask application for whose workers the manager is responsible. If the app is passed to the contructor, the manager will be initialized with the application. Otherwise, you must perform the initialization later by calling init_app . **kwargs : You can set the manager's attributes by passing them as keyword arguments. Attributes: app_import : str, default='app.app' Pythonic import path for the Flask application. e.g. if your application object is created in a file path/to/app.py and named my_app , set the app_import to path.to.app.my_app . connection : redis.client.Redis Redis connection for the workers. If not explicitly set, the manager will set the connection attribute to the app's redis attribute. In this case, the app must have a redis connection attribute named redis when the manager is initialized with the application. db : flask_sqlalchemy.SQLAlchemy Database for the flask application. loading_img_blueprint : str or None, default=None Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str, default='worker_loading.gif' Name of the loading image file. This should be in the app's static directory or a blueprint's static directory. loadering_img_src : str Loading image source path, derived from loading_img_blueprint and loading_img_filename . socketio : flask_socketio.SocketIO or None, default=None Socket object through which workers will emit job progress messages. While this argument is not required on initialization, it must be set before the app is run. template : str, default='worker/worker_loading.html' Name of the html template file for the loading page. Flask-Worker provides a default loading template. Methods init_app ( self, app, **kwargs ) [source] Initialize the manager with the application. Parameters: app : flask.app.Flask Flask application for whose workers the manager is responsible. **kwargs : You can set the manager's attributes by passing them as keyword arguments.","title":"Manager"},{"location":"manager/#manager","text":"","title":"Manager"},{"location":"manager/#flask_workermanager","text":"class flask_worker. Manager ( app=None, **kwargs ) [source] Flask extension which manages workers. The manager tracks an application import path, a redis connection, the application database, and the web socket. These tools will be invoked by workers. Parameters: app : flask.app.Flask or None, default=None Flask application for whose workers the manager is responsible. If the app is passed to the contructor, the manager will be initialized with the application. Otherwise, you must perform the initialization later by calling init_app . **kwargs : You can set the manager's attributes by passing them as keyword arguments. Attributes: app_import : str, default='app.app' Pythonic import path for the Flask application. e.g. if your application object is created in a file path/to/app.py and named my_app , set the app_import to path.to.app.my_app . connection : redis.client.Redis Redis connection for the workers. If not explicitly set, the manager will set the connection attribute to the app's redis attribute. In this case, the app must have a redis connection attribute named redis when the manager is initialized with the application. db : flask_sqlalchemy.SQLAlchemy Database for the flask application. loading_img_blueprint : str or None, default=None Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str, default='worker_loading.gif' Name of the loading image file. This should be in the app's static directory or a blueprint's static directory. loadering_img_src : str Loading image source path, derived from loading_img_blueprint and loading_img_filename . socketio : flask_socketio.SocketIO or None, default=None Socket object through which workers will emit job progress messages. While this argument is not required on initialization, it must be set before the app is run. template : str, default='worker/worker_loading.html' Name of the html template file for the loading page. Flask-Worker provides a default loading template.","title":"flask_worker.Manager"},{"location":"manager/#methods","text":"init_app ( self, app, **kwargs ) [source] Initialize the manager with the application. Parameters: app : flask.app.Flask Flask application for whose workers the manager is responsible. **kwargs : You can set the manager's attributes by passing them as keyword arguments.","title":"Methods"},{"location":"router/","text":"Routers The problem Suppose we want a view function to execute a series of function calls. During these function calls, the Worker executes its complex task. Our first pass might be to add something like the following in app.py . @app.route('/no-router') def no_router(): return func1('hello world') def func1(hello_world): print(hello_world) return func2('hello moon') def func2(hello_moon): print(hello_moon) worker = get_model(Worker, 'no_router') return func3(worker.result) if worker.job_finished else worker() def func3(hello_star): print(hello_star) db.session.commit() return 'Function calls finished.' The problem is that the entire series of function calls executes every time this view function is called. However, it may be important that we do not call func1 a second time. Ideally, we want to 'pause' the series of function calls while the complex task is executing. Once the worker has finished its job, we want to pick up where we left off. The solution A Router solves this problem by managing a series of function calls initiated by a view function. The Router tracks function calls and their arguments. It does this by 'bookmarking' its methods with the @set_route decorator. We'll put the following code at the bottom of our a models.py file. from flask_worker import RouterMixin, set_route class Router(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name super().__init__(self.func1, 'hello world') def func1(self, hello_world): print(hello_world) return self.func2('hello moon') # 'bookmark' functions with the `@set_route` decorator @set_route def func2(self, hello_moon): print(hello_moon) worker = get_model(Worker, 'routing') return self.func3('hello star') if worker.job_finished else worker() @set_route def func3(self, hello_star): print(hello_star) # optionally, reset the router self.reset() # you may also want to reset Workers which were called by the Router get_model(Worker, 'routing').reset() return 'Function calls finished.' We'll also create a view function for the Router in app.py . from models import Router @app.route('/router') def routing(): return get_model(Router, 'routing')() Note that we reset the Router and the Worker it used in func3 . If we had not reset it, the Router would have cached the result of the function calls. Try commenting out those two lines of code and rerunning your app.","title":"Routers"},{"location":"router/#routers","text":"","title":"Routers"},{"location":"router/#the-problem","text":"Suppose we want a view function to execute a series of function calls. During these function calls, the Worker executes its complex task. Our first pass might be to add something like the following in app.py . @app.route('/no-router') def no_router(): return func1('hello world') def func1(hello_world): print(hello_world) return func2('hello moon') def func2(hello_moon): print(hello_moon) worker = get_model(Worker, 'no_router') return func3(worker.result) if worker.job_finished else worker() def func3(hello_star): print(hello_star) db.session.commit() return 'Function calls finished.' The problem is that the entire series of function calls executes every time this view function is called. However, it may be important that we do not call func1 a second time. Ideally, we want to 'pause' the series of function calls while the complex task is executing. Once the worker has finished its job, we want to pick up where we left off.","title":"The problem"},{"location":"router/#the-solution","text":"A Router solves this problem by managing a series of function calls initiated by a view function. The Router tracks function calls and their arguments. It does this by 'bookmarking' its methods with the @set_route decorator. We'll put the following code at the bottom of our a models.py file. from flask_worker import RouterMixin, set_route class Router(RouterMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name super().__init__(self.func1, 'hello world') def func1(self, hello_world): print(hello_world) return self.func2('hello moon') # 'bookmark' functions with the `@set_route` decorator @set_route def func2(self, hello_moon): print(hello_moon) worker = get_model(Worker, 'routing') return self.func3('hello star') if worker.job_finished else worker() @set_route def func3(self, hello_star): print(hello_star) # optionally, reset the router self.reset() # you may also want to reset Workers which were called by the Router get_model(Worker, 'routing').reset() return 'Function calls finished.' We'll also create a view function for the Router in app.py . from models import Router @app.route('/router') def routing(): return get_model(Router, 'routing')() Note that we reset the Router and the Worker it used in func3 . If we had not reset it, the Router would have cached the result of the function calls. Try commenting out those two lines of code and rerunning your app.","title":"The solution"},{"location":"router_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Routers flask_worker. set_route def flask_worker. set_route ( func ) [source] The @set_route decorator bookmarks the current function call. Specifically, it sets the Router's func to the the current function and stores the args and kwargs. flask_worker. RouterMixin class flask_worker. RouterMixin ( func, *args, **kwargs ) [source] Mixin for Router models. A Router manages a series of function calls initiated by a view function. These function calls must be methods of the Router. Suppose a view function initiates a series of function calls which include calling a Router. The Router can 'bookmark' its methods; if this Router is called in the future, it will pick up its series of function calls at the bookmarked method. Parameters: func : callable The function executed when the Router is called. *args, **kwargs : Arguments and keyword arguments passed to func . Attributes: func : callable Set from the func parameter. args : list, default=[] Set from the *args parameter. kwargs : dict, default={} Set from the **kwargs parameter. init_func : callable Set from the func parameter. func is reset to init_func when the Router's reset method is called. init_args : list, default=[] Set from the *args parameter. args is reset to init_args when the Router's reset method is called. init_kwargs : dict, default={} Similarly defined. Methods __call__ ( self ) [source] Calls self.func , passing in self.args and self.kwargs . Returns: page_html : str Html of the page returned by the current route. reset ( self ) [source] Reset self.func , self.args , and self.kwargs to their initial values. Returns: self : flask_worker.RouterMixin","title":"Routers"},{"location":"router_mixin/#routers","text":"","title":"Routers"},{"location":"router_mixin/#flask_workerset_route","text":"def flask_worker. set_route ( func ) [source] The @set_route decorator bookmarks the current function call. Specifically, it sets the Router's func to the the current function and stores the args and kwargs.","title":"flask_worker.set_route"},{"location":"router_mixin/#flask_workerroutermixin","text":"class flask_worker. RouterMixin ( func, *args, **kwargs ) [source] Mixin for Router models. A Router manages a series of function calls initiated by a view function. These function calls must be methods of the Router. Suppose a view function initiates a series of function calls which include calling a Router. The Router can 'bookmark' its methods; if this Router is called in the future, it will pick up its series of function calls at the bookmarked method. Parameters: func : callable The function executed when the Router is called. *args, **kwargs : Arguments and keyword arguments passed to func . Attributes: func : callable Set from the func parameter. args : list, default=[] Set from the *args parameter. kwargs : dict, default={} Set from the **kwargs parameter. init_func : callable Set from the func parameter. func is reset to init_func when the Router's reset method is called. init_args : list, default=[] Set from the *args parameter. args is reset to init_args when the Router's reset method is called. init_kwargs : dict, default={} Similarly defined.","title":"flask_worker.RouterMixin"},{"location":"router_mixin/#methods","text":"__call__ ( self ) [source] Calls self.func , passing in self.args and self.kwargs . Returns: page_html : str Html of the page returned by the current route. reset ( self ) [source] Reset self.func , self.args , and self.kwargs to their initial values. Returns: self : flask_worker.RouterMixin","title":"Methods"},{"location":"run/","text":"Running the app Make sure you have two terminal windows open, and navigate to your root directory in both. Running Redis In one terminal window, we'll run the Redis Queue . $ rq run my-task-queue In your window, you should see a message like: 15:46:03: Worker rq:worker:e9f2ed95fc3e48429fc3962fe0f0c03b: started, version 1.2.0 15:46:03: *** Listening on my-task-queue... 15:46:03: Cleaning registries for queue: my-task-queue Note that you can change the name of the task queue in the application factory . Running the app In the other terminal window, we'll run the Flask app. $ python app.py In your window, you should see a message like: 15:54:51: Server initialized for eventlet. 15:54:51: * Restarting with stat 15:54:52: Server initialized for eventlet. 15:54:52: * Debugger is active! 15:54:52: * Debugger PIN: 183-643-336 (3516) wsgi starting up on http://127.0.0.1:5000 Viewing the app Navigate to http://localhost:5000 in your browser. Notice the following message in your redis terminal: Complex task started Progress: 0.0% Progress: 20.0% Progress: 40.0% Progress: 60.0% Progress: 80.0% Progress: 100.0% Complex task finished While the complex task is executing, you'll see the loading gif in your browser. After the worker has finished, the page will reload with a 'Hello, World!' message.","title":"Running the app"},{"location":"run/#running-the-app","text":"Make sure you have two terminal windows open, and navigate to your root directory in both.","title":"Running the app"},{"location":"run/#running-redis","text":"In one terminal window, we'll run the Redis Queue . $ rq run my-task-queue In your window, you should see a message like: 15:46:03: Worker rq:worker:e9f2ed95fc3e48429fc3962fe0f0c03b: started, version 1.2.0 15:46:03: *** Listening on my-task-queue... 15:46:03: Cleaning registries for queue: my-task-queue Note that you can change the name of the task queue in the application factory .","title":"Running Redis"},{"location":"run/#running-the-app_1","text":"In the other terminal window, we'll run the Flask app. $ python app.py In your window, you should see a message like: 15:54:51: Server initialized for eventlet. 15:54:51: * Restarting with stat 15:54:52: Server initialized for eventlet. 15:54:52: * Debugger is active! 15:54:52: * Debugger PIN: 183-643-336 (3516) wsgi starting up on http://127.0.0.1:5000","title":"Running the app"},{"location":"run/#viewing-the-app","text":"Navigate to http://localhost:5000 in your browser. Notice the following message in your redis terminal: Complex task started Progress: 0.0% Progress: 20.0% Progress: 40.0% Progress: 60.0% Progress: 80.0% Progress: 100.0% Complex task finished While the complex task is executing, you'll see the loading gif in your browser. After the worker has finished, the page will reload with a 'Hello, World!' message.","title":"Viewing the app"},{"location":"view/","text":"View functions Now we can use the Worker in our view functions. Setup By default, the Manager expects the Flask application to be an object named app in a file in the root directory called app.py . (You can change this by setting the Manager's app_import attribute). For the tutorial, we'll stick with the default. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py All of the code in this part of the tutorial goes in the app.py file. from factory import create_app, db, socketio from models import Worker, get_model app = create_app() # create database before first app request @app.before_first_request def before_first_request(): db.create_all() # VIEW FUNCTIONS GO HERE if __name__ == '__main__': socketio.run(app, debug=True) Basic use This is a basic example in which the Worker executes its complex task. The Worker only sends its complex task to the Redis Queue once, regardless of how many times the client requests this route. Until the Worker finishes its job, it returns a loading page. The result is cached once the Worker finishes its job, so that future calls to this route will not re-run the complex task. @app.route('/') @app.route('/index') def index(): worker = get_model(Worker, 'index') return worker.result if worker.job_finished else worker() We are now ready to run our app . Resetting a Worker In this example, we reset the Worker after it has finished its job. This means that future calls to this route will re-run the complex task. @app.route('/reset') def with_reset(): worker = get_model(Worker, 'reset') if not worker.job_finished: return worker() worker.reset() db.session.commit() return worker.result Callback routes This example demonstrates how to use a Worker's callback function. By default, when a Worker finishes its job, it issues another call to the current view function. Set the worker's callback attribute to the name of another view function to redirect the client after the Worker finishes its job. @app.route('/callback') def with_callback(): worker = get_model(Worker, 'callback') worker.callback = 'callback_route' if worker.job_finished: worker.reset() return worker() @app.route('/callback_route') def callback_route(): worker = get_model(Worker, 'callback') return worker.result if worker.job_finished else worker()","title":"View functions"},{"location":"view/#view-functions","text":"Now we can use the Worker in our view functions.","title":"View functions"},{"location":"view/#setup","text":"By default, the Manager expects the Flask application to be an object named app in a file in the root directory called app.py . (You can change this by setting the Manager's app_import attribute). For the tutorial, we'll stick with the default. Our folder looks like: static/ worker_loading.gif app.py factory.py models.py All of the code in this part of the tutorial goes in the app.py file. from factory import create_app, db, socketio from models import Worker, get_model app = create_app() # create database before first app request @app.before_first_request def before_first_request(): db.create_all() # VIEW FUNCTIONS GO HERE if __name__ == '__main__': socketio.run(app, debug=True)","title":"Setup"},{"location":"view/#basic-use","text":"This is a basic example in which the Worker executes its complex task. The Worker only sends its complex task to the Redis Queue once, regardless of how many times the client requests this route. Until the Worker finishes its job, it returns a loading page. The result is cached once the Worker finishes its job, so that future calls to this route will not re-run the complex task. @app.route('/') @app.route('/index') def index(): worker = get_model(Worker, 'index') return worker.result if worker.job_finished else worker() We are now ready to run our app .","title":"Basic use"},{"location":"view/#resetting-a-worker","text":"In this example, we reset the Worker after it has finished its job. This means that future calls to this route will re-run the complex task. @app.route('/reset') def with_reset(): worker = get_model(Worker, 'reset') if not worker.job_finished: return worker() worker.reset() db.session.commit() return worker.result","title":"Resetting a Worker"},{"location":"view/#callback-routes","text":"This example demonstrates how to use a Worker's callback function. By default, when a Worker finishes its job, it issues another call to the current view function. Set the worker's callback attribute to the name of another view function to redirect the client after the Worker finishes its job. @app.route('/callback') def with_callback(): worker = get_model(Worker, 'callback') worker.callback = 'callback_route' if worker.job_finished: worker.reset() return worker() @app.route('/callback_route') def callback_route(): worker = get_model(Worker, 'callback') return worker.result if worker.job_finished else worker()","title":"Callback routes"},{"location":"worker/","text":"Workers A Worker executes a complex task by sending it to a Redis queue. While the client is waiting for the complex task to finish, the Worker sends the client a loading page. We'll create the Worker model in a file called models.py . Our folder now looks like: factory.py models.py from factory import db from flask_worker import WorkerMixin def complex_task(seconds): import time print('Complex task started') for i in range(seconds): print('Progress: {}%'.format(100.0*i/seconds)) time.sleep(1) print('Progress: 100.0%') print('Complex task finished') return 'Hello, World!' # create a Worker model with the worker mixin class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name # set the worker's complex task along with args and kwargs self.set(complex_task, seconds=5) super().__init__() We'll also define a convenience method at the bottom of this file for database querying. This function returns a model of the type class_ with the specified name . If this model does not yet exist, this function creates it. ... def get_model(class_, name): return class_.query.filter_by(name=name).first() or class_(name)","title":"Workers"},{"location":"worker/#workers","text":"A Worker executes a complex task by sending it to a Redis queue. While the client is waiting for the complex task to finish, the Worker sends the client a loading page. We'll create the Worker model in a file called models.py . Our folder now looks like: factory.py models.py from factory import db from flask_worker import WorkerMixin def complex_task(seconds): import time print('Complex task started') for i in range(seconds): print('Progress: {}%'.format(100.0*i/seconds)) time.sleep(1) print('Progress: 100.0%') print('Complex task finished') return 'Hello, World!' # create a Worker model with the worker mixin class Worker(WorkerMixin, db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String) def __init__(self, name): self.name = name # set the worker's complex task along with args and kwargs self.set(complex_task, seconds=5) super().__init__() We'll also define a convenience method at the bottom of this file for database querying. This function returns a model of the type class_ with the specified name . If this model does not yet exist, this function creates it. ... def get_model(class_, name): return class_.query.filter_by(name=name).first() or class_(name)","title":"Workers"},{"location":"worker_mixin/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Workers flask_worker. WorkerMixin class flask_worker. WorkerMixin ( template=None, **kwargs ) [source] The worker executes a complex task using a Redis queue. When called, it enqueues a job and returns a loading page. When a Redis worker grabs the enqueued job, it executes the worker's function, func , passing in the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. func : callable Function which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image. result : Output of the worker's function. This stores the result of the job the worker executed. Methods reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the worker's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Workers"},{"location":"worker_mixin/#workers","text":"","title":"Workers"},{"location":"worker_mixin/#flask_workerworkermixin","text":"class flask_worker. WorkerMixin ( template=None, **kwargs ) [source] The worker executes a complex task using a Redis queue. When called, it enqueues a job and returns a loading page. When a Redis worker grabs the enqueued job, it executes the worker's function, func , passing in the worker's args and kwargs . After execution, the worker's script replaces the client's window location with a call to its callback view function. Parameters: template : str or None, default=None Name of the html template file for the worker's loading page. If None , the worker will use the manager's loading page template. **kwargs : You can set the worker's attributes by passing them as keyword arguments. Attributes: manager : flask_worker.Manager The worker's manager. func : callable Function which the worker will execute. args : list, default=[] Arguments which will be passed to the executed method. kwargs : dict, default={} Keyword arguments which will be passed to the executed method. callback : str or None, default=None Name of the view function to which the client will navigate once the worker has finished its job. If None , the current view function is re-called. job_finished : bool, default=False Indicates that the worker has finished its job. job_in_progress : bool, default=False Indicates that the worker has a job in progress. job_id : str Identifier for the worker's job. loading_page : sqlalchemy_mutablesoup.MutableSoup Loading page which will be displayed to the client while the worker performs its job. loading_img : bs4.Tag <img> tag for the loading image. loading_img_src : str Source of the loading image. result : Output of the worker's function. This stores the result of the job the worker executed.","title":"flask_worker.WorkerMixin"},{"location":"worker_mixin/#methods","text":"reset ( self ) [source] Clears the job_finished , job_in_progress , and job_id attributes. Returns: self : flask_worker.WorkerMixin __call__ ( self ) [source] Enqueue the worker's job for execution if it is not enqueued already. Returns: loading_page : str (html) The client's loading page.","title":"Methods"}]}